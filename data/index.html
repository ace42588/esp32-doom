<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>ESP32 Doom Framebuffer Viewer</title>
  <style>
    body { background: #111; color: #eee; text-align: center; }
    canvas { background: #000; margin-top: 20px; }
  </style>
</head>
<body>
  <canvas id="fb" width="320" height="240"></canvas>
  <script type="module">
    import { doomColors } from './doom-palette.js';
    
    // Set these to match your framebuffer size
    const WIDTH = 320;
    const HEIGHT = 240;
    const BYTES_PER_PIXEL = 1; // 8bpp indexed color
    const EXPECTED_FRAME_SIZE = WIDTH * HEIGHT * BYTES_PER_PIXEL + 1; // +1 for palette index
    
    const canvas = document.getElementById('fb');
    const ctx = canvas.getContext('2d');
    const imageData = ctx.createImageData(WIDTH, HEIGHT);
    
    // Local framebuffer to store current frame state
    const framebuffer = new Uint8Array(WIDTH * HEIGHT * BYTES_PER_PIXEL);

    // Connect to the ESP32 WebSocket server on port 8080
    const ws = new WebSocket('ws://' + location.hostname + ':8080');

    ws.binaryType = 'arraybuffer';

    ws.onopen = () => {
      console.log('WebSocket connected');
    };

    ws.onmessage = (event) => {
      if (event.data instanceof ArrayBuffer) {
        const data = new Uint8Array(event.data);
        
        // Debug: Log received data details
        console.log('Received WebSocket data:', {
          size: data.length,
          expectedSize: EXPECTED_FRAME_SIZE,
          paletteIndex: data[0]
        });
        
        // Check if we received a complete frame
        if (data.length === EXPECTED_FRAME_SIZE) {
          const paletteIndex = data[0]; // First byte is palette index
          const framebufferData = data.slice(1); // All but first byte is framebuffer data
          
          console.log('Processing frame:', {
            frameSize: framebufferData.length,
            paletteIndex: paletteIndex
          });
          
          // Update our local framebuffer copy
          framebuffer.set(framebufferData);
          
          // Convert 8bpp indexed color to RGBA using DOOM palette
          for (let i = 0; i < framebuffer.length; i++) {
            const pixel = framebuffer[i];
            const idx = i * 4;
            // Calculate palette offset: paletteIndex * 256 entries * 3 RGB values
            const paletteOffset = paletteIndex * 256 * 3;
            const colorIdx = paletteOffset + pixel * 3;
            // Use DOOM palette colors from the specified palette
            imageData.data[idx] = doomColors[colorIdx];     // R
            imageData.data[idx + 1] = doomColors[colorIdx + 1]; // G
            imageData.data[idx + 2] = doomColors[colorIdx + 2]; // B
            imageData.data[idx + 3] = 255;   // A
          }
          ctx.putImageData(imageData, 0, 0);
        } else {
          console.warn('Received frame of unexpected size:', data.length, 'bytes (expected', EXPECTED_FRAME_SIZE, 'bytes)');
        }
      } else {
        console.warn('Received non-binary data:', typeof event.data);
      }
    };

    ws.onerror = (err) => {
      console.error('WebSocket error:', err);
    };

    ws.onclose = () => {
      console.log('WebSocket closed');
    };
  </script>
</body>
</html>