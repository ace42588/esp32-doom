<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>ESP32 Doom</title>
  <style>
    body { background: #111; color: #eee; text-align: center; }
    canvas { background: #000; margin-top: 20px; }
  </style>
</head>
<body>
  <canvas id="fb" width="320" height="240"></canvas>
  <script type="module">
    import { doomColors } from './doom-palette.js';
    
    // Set these to match your framebuffer size
    const WIDTH = 320;
    const HEIGHT = 240;
    const BYTES_PER_PIXEL = 1; // 8bpp indexed color
    const EXPECTED_FRAME_SIZE = WIDTH * HEIGHT * BYTES_PER_PIXEL + 1; // +1 for palette index
    
    // Input handling constants
    const WS_MSG_INPUT_KEYDOWN = 0x01;
    const WS_MSG_INPUT_KEYUP = 0x02;
    const WS_MSG_INPUT_MOUSE_MOVE = 0x03;
    const WS_MSG_INPUT_MOUSE_BTN = 0x04;
    const WS_MSG_INPUT_JOYSTICK = 0x05;
    
    const canvas = document.getElementById('fb');
    const ctx = canvas.getContext('2d');
    const imageData = ctx.createImageData(WIDTH, HEIGHT);
    
    // Local framebuffer to store current frame state
    const framebuffer = new Uint8Array(WIDTH * HEIGHT * BYTES_PER_PIXEL);

    // Connect to the ESP32 WebSocket server on port 8080
    const ws = new WebSocket('ws://' + location.hostname + ':8080');

    ws.binaryType = 'arraybuffer';

    ws.onopen = () => {
      console.log('WebSocket connected');
    };

    ws.onmessage = (event) => {
      if (event.data instanceof ArrayBuffer) {
        const data = new Uint8Array(event.data);
        
        // Debug: Log received data details
        console.log('Received WebSocket data:', {
          size: data.length,
          expectedSize: EXPECTED_FRAME_SIZE,
          paletteIndex: data[0]
        });
        
        // Check if we received a complete frame
        if (data.length === EXPECTED_FRAME_SIZE) {
          const paletteIndex = data[0]; // First byte is palette index
          const framebufferData = data.slice(1); // All but first byte is framebuffer data
          
          console.log('Processing frame:', {
            frameSize: framebufferData.length,
            paletteIndex: paletteIndex
          });
          
          // Update our local framebuffer copy
          framebuffer.set(framebufferData);
          
          // Convert 8bpp indexed color to RGBA using DOOM palette
          for (let i = 0; i < framebuffer.length; i++) {
            const pixel = framebuffer[i];
            const idx = i * 4;
            // Calculate palette offset: paletteIndex * 256 entries * 3 RGB values
            const paletteOffset = paletteIndex * 256 * 3;
            const colorIdx = paletteOffset + pixel * 3;
            // Use DOOM palette colors from the specified palette
            imageData.data[idx] = doomColors[colorIdx];     // R
            imageData.data[idx + 1] = doomColors[colorIdx + 1]; // G
            imageData.data[idx + 2] = doomColors[colorIdx + 2]; // B
            imageData.data[idx + 3] = 255;   // A
          }
          ctx.putImageData(imageData, 0, 0);
        } else {
          console.warn('Received frame of unexpected size:', data.length, 'bytes (expected', EXPECTED_FRAME_SIZE, 'bytes)');
        }
      } else {
        console.warn('Received non-binary data:', typeof event.data);
      }
    };

    ws.onerror = (err) => {
      console.error('WebSocket error:', err);
    };

    ws.onclose = () => {
      console.log('WebSocket closed');
    };
    
    // Input handling functions
    function sendInputMessage(type, data1, data2, data3) {
      if (ws.readyState === WebSocket.OPEN) {
        const message = new Uint8Array([type, data1, data2, data3]);
        ws.send(message);
      }
    }
    
    // Keyboard input handling
    const keyState = new Set();
    
    document.addEventListener('keydown', (event) => {
      if (!keyState.has(event.code)) {
        keyState.add(event.code);
        sendInputMessage(WS_MSG_INPUT_KEYDOWN, event.keyCode, 0, 0);
        console.log('Key down:', event.code, event.keyCode);
      }
      event.preventDefault();
    });
    
    document.addEventListener('keyup', (event) => {
      keyState.delete(event.code);
      sendInputMessage(WS_MSG_INPUT_KEYUP, event.keyCode, 0, 0);
      console.log('Key up:', event.code, event.keyCode);
      event.preventDefault();
    });
    
    // Mouse input handling
    let mouseButtons = 0;
    let lastMouseX = 0;
    let lastMouseY = 0;
    
    canvas.addEventListener('mousedown', (event) => {
      const button = event.button;
      mouseButtons |= (1 << button);
      sendInputMessage(WS_MSG_INPUT_MOUSE_BTN, mouseButtons, 0, 0);
      console.log('Mouse down:', button, 'buttons:', mouseButtons);
      event.preventDefault();
    });
    
    canvas.addEventListener('mouseup', (event) => {
      const button = event.button;
      mouseButtons &= ~(1 << button);
      sendInputMessage(WS_MSG_INPUT_MOUSE_BTN, mouseButtons, 0, 0);
      console.log('Mouse up:', button, 'buttons:', mouseButtons);
      event.preventDefault();
    });
    
    canvas.addEventListener('mousemove', (event) => {
      const rect = canvas.getBoundingClientRect();
      const x = event.clientX - rect.left;
      const y = event.clientY - rect.top;
      
      // Calculate relative movement
      const deltaX = x - lastMouseX;
      const deltaY = y - lastMouseY;
      
      if (Math.abs(deltaX) > 0 || Math.abs(deltaY) > 0) {
        sendInputMessage(WS_MSG_INPUT_MOUSE_MOVE, 0, deltaX, deltaY);
        console.log('Mouse move:', deltaX, deltaY);
      }
      
      lastMouseX = x;
      lastMouseY = y;
      event.preventDefault();
    });
    
    // Prevent context menu on right-click
    canvas.addEventListener('contextmenu', (event) => {
      event.preventDefault();
    });
    
    // Focus the canvas to capture keyboard input
    canvas.focus();
    canvas.setAttribute('tabindex', '0');
    
    // Keep focus on canvas
    document.addEventListener('click', () => {
      canvas.focus();
    });
  </script>
</body>
</html>